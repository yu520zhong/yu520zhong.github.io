<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[什么是响应式Web设计，响应式Web设计需要应用哪些技术?]]></title>
      <url>/2017/10/09/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E8%AE%BE%E8%AE%A1%E9%9C%80%E8%A6%81%E5%BA%94%E7%94%A8%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>响应式Web设计是关于网站的制作或网页制作的工作。不同的设备有不同的尺寸和不同的功能，响应式设计是让所有的人能在这些设备上让网站运行正常。</p>
<p>响应式Web设计是和HTML5+CSS3互相配合与支持的，实现响应式设计包括以下技术点：</p>
<p>⊙HTML5+CSS3的基本网页设计。</p>
<p>⊙HTML5标签viewport：提供可以配置视口的属性。</p>
<p>⊙CSS3媒体查询（media queries）：识别媒体类型，特征（屏幕宽度，像素比等）。</p>
<p>⊙流式布局（fluid layout）：可以根据浏览器的宽度和屏幕的大小自动调整效果。</p>
<p>⊙响应式网格（Responsesive fluid grid）：依赖于媒体查询，根据不同的屏幕大小调整布局。</p>
<p>⊙流式图片（fluid images）：随流式布局进行相应缩放。</p>
]]></content>
      
        
        <tags>
            
            <tag> 响应式Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery 操作复选框的N个方法]]></title>
      <url>/2017/10/09/jQuery-%E6%93%8D%E4%BD%9C%E5%A4%8D%E9%80%89%E6%A1%86%E7%9A%84N%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>1、获取单个checkbox选中项(三种写法)<br>$(“input:checkbox:checked”).val()<br>或者<br>$(“input:[type=’checkbox’]:checked”).val();<br>或者<br>$(“input:[name=’ck’]:checked”).val();<br>2、 获取多个checkbox选中项<br>$(‘input:checkbox’).each(function() {<br>if ($(this).attr(‘checked’) ==true) {<br>alert($(this).val());<br>}<br>});<br>3、设置第一个checkbox 为选中值<br>$(‘input:checkbox:first’).attr(“checked”,’checked’);<br>或者<br>$(‘input:checkbox’).eq(0).attr(“checked”,’true’);<br>4、设置最后一个checkbox为选中值<br>$(‘input:radio:last’).attr(‘checked’, ‘checked’);<br>或者<br>$(‘input:radio:last’).attr(‘checked’, ‘true’);<br>5、根据索引值设置任意一个checkbox为选中值<br>$(‘input:checkbox).eq(索引值).attr(‘checked’, ‘true’);索引值=0,1,2….<br>或者<br>$(‘input:radio’).slice(1,2).attr(‘checked’, ‘true’);<br>6、选中多个checkbox同时选中第1个和第2个的checkbox<br>$(‘input:radio’).slice(0,2).attr(‘checked’,’true’);<br>7、根据Value值设置checkbox为选中值<br>$(“input:checkbox[value=’1’]”).attr(‘checked’,’true’);<br>8、删除Value=1的checkbox<br>$(“input:checkbox[value=’1’]”).remove();<br>9、删除第几个checkbox<br>$(“input:checkbox”).eq(索引值).remove();索引值=0,1,2….<br>如删除第3个checkbox:<br>$(“input:checkbox”).eq(2).remove();<br>10、遍历checkbox<br>$(‘input:checkbox’).each(function (index, domEle) {<br>//写入代码<br>});<br>11、全部选中<br>$(‘input:checkbox’).each(function() {<br>$(this).attr(‘checked’, true);<br>});<br>12、全部取消选择<br>$(‘input:checkbox’).each(function () {<br>$(this).attr(‘checked’,false);<br>});</p>
]]></content>
      
        
        <tags>
            
            <tag> 复选框 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我喜欢的JS命名规则]]></title>
      <url>/2017/09/26/%E6%88%91%E5%96%9C%E6%AC%A2%E7%9A%84JS%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
      <content type="html"><![CDATA[<p>JS命名方法有很多种,根据喜欢不同,一般情况下,我喜欢使用这样的命名我的JS:<br>命名变量,用下划线来分割各个单词,其中前缀使用名词,并尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型,如<strong>title_text,max_count,current_abbr,table_title</strong>;<a id="more"></a><br>命名函数,采用小驼峰式命名法,首字母小写,名字前缀为动词，以便区分变量和函数。如<strong>displayAbbreviations(),addLoadEvent(),getName()</strong>;<br>这样我就可以一样看出哪些是变量,哪些是函数。<br>常量名称全部大写,使用大写字母和下划线来组合命名，下划线用以分割单词。如<strong>var MIN_COUNT = 10;</strong><br>构造函数,其采用new 运算符创建对象,使用大驼峰式命名法，首字母大写,前缀为名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Student(name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">var student_name = new Student(&apos;tom&apos;);</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS命名规则 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于html5的webstorage——静态传值]]></title>
      <url>/2017/09/25/%E5%85%B3%E4%BA%8Ehtml5%E7%9A%84webstorage%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E4%BC%A0%E5%80%BC/</url>
      <content type="html"><![CDATA[<p>html5静态页面之间的传值: <strong>localStorage、sessionStorage</strong><br>随着H5的到来，它提供了新的web存储，webstorage，包含了localStorage和sessionStorage<br>localStorage：一种没有时间限制的缓存，我们不手动清理，就不丢失<br>sessionStorage：用户的窗口执行了关闭操作，sessionStorage的数据会丢失<a id="more"></a><br>先检测浏览器是不是支持H5的存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (window.localStorage &amp;&amp; window.sessionStorage) &#123;</div><div class="line">      alert(&quot;你的浏览器支持localStorage和sessionStorage&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>创建一个localStorage存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//先判断支持</div><div class="line"> if (window.localStorage) &#123; localStorage.setItem(&quot;userName&quot;, &quot;张龙&quot;); &#125;</div></pre></td></tr></table></figure></p>
<p>获取localStorage存储的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localStorage.getItem(&quot;userName&quot;);</div></pre></td></tr></table></figure></p>
<p>最后操作删除localStorage存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localStorage.removeItem(&quot;userName&quot;);</div></pre></td></tr></table></figure></p>
<p>//关闭缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">localStorage.clear();</div></pre></td></tr></table></figure></p>
<p>sessionStorage操作和localStorage基本操作一样！</p>
]]></content>
      
        <categories>
            
            <category> h5/css3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> localStorage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webstorm支持sass的同步编译设置方法]]></title>
      <url>/2017/09/25/webstorm%E6%94%AF%E6%8C%81sass%E7%9A%84%E5%90%8C%E6%AD%A5%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>webstorm支持sass的同步编译,也就是即写即编译,并且可以指定编译后的css的目录。<br>打开webstorm：<br>点击左上角的File→Settings→File Watchers<br>在弹窗的窗口的右上角点击绿色的 ‘+’ 号,然后选择scss<br><a id="more"></a>Arguments:<br>可以配置编译后的文件的输出路径,我这里写的是:<br>–no-cache –update –sourcemap –watch $FileName$:$FileParentDir$/css/$FileNameWithoutExtension$.css<br>注意, $FileName$后面有个冒号,然后$FileParentDir$表示的是scss文件所在的文件夹的父级文件夹,而不是scss文件的父文件夹。<br>举个栗子,我的项目叫sass-learn,里面有个scss文件夹,里面存放scss文件,那么按照这样配置的结果,style.scss所在的文件夹就是scss,scss的父文件夹就是sass-learn,然后找到sass-learn下的css文件夹,编译后的style.css文件就会在这里。<br>Output paths to refresh:<br>改成这样:$FileNameWithoutExtension$.css:$FileNameWithoutExtension$.css.map</p>
]]></content>
      
        <categories>
            
            <category> sass </category>
            
        </categories>
        
        
        <tags>
            
            <tag> webstrom </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[又是一天]]></title>
      <url>/2017/09/22/%E5%8F%88%E6%98%AF%E4%B8%80%E5%A4%A9/</url>
      <content type="html"><![CDATA[<p>时间过得真快,又是一天,已经是又一个周五的晚上。<br><a id="more"></a><br>一个人在次卧的床上，听着歌，妻和嘟嘟都睡了。静静的夜里，远处小区的河边蛐蛐不停歇的叫声。手机里随机放着歌曲，陈粒的《奇妙能力歌》，只是随便听听，连一句歌词都没有记住，更不知道唱的什么意思。这样的夜不知道有多少，而白日却雷同地过着。轻叹一声，时间过得真快呀。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随便写写 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随便写写]]></title>
      <url>/2017/09/21/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/</url>
      <content type="html"><![CDATA[<p>有时候很忙,就随便写写,有时候很闲,却不愿意写点什么。<br><a id="more"></a>感觉没有紧迫感的时候，什么也做不成，有了紧迫感，却又感觉压力倍增。哎，随便写写吧，看了挤出来的时间，才会知道珍惜利用。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随便写写 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对于React-React Native 的ES5 ES6写法对照表]]></title>
      <url>/2017/09/07/%E5%AF%B9%E4%BA%8EReact-React%20Native%20%E7%9A%84ES5%20ES6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center">很多React/React Native的初学者都被ES6的问题迷惑：各路大神都建议我们直接学习ES6的语法(class Foo extends React.Component)，然而网上搜到的很多教程和例子都是ES5版本的，所以很多人在学习的时候连照猫画虎都不知道怎么做。今天在此整理了一些ES5和ES6的写法对照表，希望大家以后读到ES5的代码，也能通过对照，在ES6下实现相同的功能。<br></blockquote><br><a id="more"></a></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">"react"</span>);</div><div class="line"><span class="keyword">var</span> &#123;</div><div class="line">    Component,</div><div class="line">    PropTypes</div><div class="line">&#125; = React;  <span class="comment">//引用React抽象组件</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> ReactNative = <span class="built_in">require</span>(<span class="string">"react-native"</span>);</div><div class="line"><span class="keyword">var</span> &#123;</div><div class="line">    Image,</div><div class="line">    Text,</div><div class="line">&#125; = ReactNative;  <span class="comment">//引用具体的React Native组件</span></div></pre></td></tr></table></figure></p>
<p>在ES6里，import写法更为标准<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">import</span> React, &#123;</div><div class="line">    Component,</div><div class="line">    PropTypes,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Image,</div><div class="line">    Text</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span></div></pre></td></tr></table></figure></p>
<p>导出单个类</p>
<p>在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</div><div class="line">    ...</div><div class="line">&#125;);</div><div class="line"><span class="built_in">module</span>.exports = MyComponent;</div></pre></td></tr></table></figure></p>
<p>在ES6里，通常用export default来实现相同的功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>引用的时候也类似：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5</span></div><div class="line"><span class="keyword">var</span> MyComponent = <span class="built_in">require</span>(<span class="string">'./MyComponent'</span>);</div><div class="line"></div><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent'</span>;</div></pre></td></tr></table></figure></p>
<p>注意导入和导出的写法必须配套，不能混用！</p>
<h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><p>在ES5里，通常通过React.createClass来定义一个组件类，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">var Photo = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        return (</div><div class="line">            &lt;Image source=&#123;this.props.source&#125; /&gt;</div><div class="line">        );</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">class Photo extends React.Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;Image source=&#123;this.props.source&#125; /&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="给组件定义方法"><a href="#给组件定义方法" class="headerlink" title="给组件定义方法"></a>给组件定义方法</h3><p>从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">var Photo = React.createClass(&#123;</div><div class="line">    componentWillMount: function()&#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">        return (</div><div class="line">            &lt;Image source=&#123;this.props.source&#125; /&gt;</div><div class="line">        );</div><div class="line">    &#125;,</div><div class="line">&#125;);</div><div class="line">//ES6</div><div class="line">class Photo extends React.Component &#123;</div><div class="line">    componentWillMount() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;Image source=&#123;this.props.source&#125; /&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定义组件的属性类型和默认属性"><a href="#定义组件的属性类型和默认属性" class="headerlink" title="定义组件的属性类型和默认属性"></a>定义组件的属性类型和默认属性</h3><p>在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">var Video = React.createClass(&#123;</div><div class="line">    getDefaultProps: function() &#123;</div><div class="line">        return &#123;</div><div class="line">            autoPlay: false,</div><div class="line">            maxLoops: 10,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">    propTypes: &#123;</div><div class="line">        autoPlay: React.PropTypes.bool.isRequired,</div><div class="line">        maxLoops: React.PropTypes.number.isRequired,</div><div class="line">        posterFrameSrc: React.PropTypes.string.isRequired,</div><div class="line">        videoSrc: React.PropTypes.string.isRequired,</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View /&gt;</div><div class="line">        );</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在ES6里，可以统一使用static成员来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">class Video extends React.Component &#123;</div><div class="line">    static defaultProps = &#123;</div><div class="line">        autoPlay: false,</div><div class="line">        maxLoops: 10,</div><div class="line">    &#125;;  // 注意这里有分号</div><div class="line">    static propTypes = &#123;</div><div class="line">        autoPlay: React.PropTypes.bool.isRequired,</div><div class="line">        maxLoops: React.PropTypes.number.isRequired,</div><div class="line">        posterFrameSrc: React.PropTypes.string.isRequired,</div><div class="line">        videoSrc: React.PropTypes.string.isRequired,</div><div class="line">    &#125;;  // 注意这里有分号</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View /&gt;</div><div class="line">        );</div><div class="line">    &#125; // 注意这里既没有分号也没有逗号</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">class Video extends React.Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View /&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Video.defaultProps = &#123;</div><div class="line">    autoPlay: false,</div><div class="line">    maxLoops: 10,</div><div class="line">&#125;;</div><div class="line">Video.propTypes = &#123;</div><div class="line">    autoPlay: React.PropTypes.bool.isRequired,</div><div class="line">    maxLoops: React.PropTypes.number.isRequired,</div><div class="line">    posterFrameSrc: React.PropTypes.string.isRequired,</div><div class="line">    videoSrc: React.PropTypes.string.isRequired,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。</p>
<h3 id="初始化STATE"><a href="#初始化STATE" class="headerlink" title="初始化STATE"></a>初始化STATE</h3><p>ES5下情况类似，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">var Video = React.createClass(&#123;</div><div class="line">    getInitialState: function() &#123;</div><div class="line">        return &#123;</div><div class="line">            loopsRemaining: this.props.maxLoops,</div><div class="line">        &#125;;</div><div class="line">    &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>ES6下，有两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">class Video extends React.Component &#123;</div><div class="line">    state = &#123;</div><div class="line">        loopsRemaining: this.props.maxLoops,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">class Video extends React.Component &#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">        this.state = &#123;</div><div class="line">            loopsRemaining: this.props.maxLoops,</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="把方法作为回调提供"><a href="#把方法作为回调提供" class="headerlink" title="把方法作为回调提供"></a>把方法作为回调提供</h2><p>很多习惯于ES6的用户反而不理解在ES5下可以这么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//ES5</div><div class="line">var PostInfo = React.createClass(&#123;</div><div class="line">    handleOptionsButtonClick: function(e) &#123;</div><div class="line">        // Here, &apos;this&apos; refers to the component instance.</div><div class="line">        this.setState(&#123;showOptionsModal: true&#125;);</div><div class="line">    &#125;,</div><div class="line">    render: function()&#123;</div><div class="line">        return (</div><div class="line">            &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick&#125;&gt;</div><div class="line">                &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">        )</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。</p>
<p>在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//ES6</div><div class="line">class PostInfo extends React.Component</div><div class="line">&#123;</div><div class="line">    handleOptionsButtonClick(e)&#123;</div><div class="line">        this.setState(&#123;showOptionsModal: true&#125;);</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        return (</div><div class="line">            &lt;TouchableHighlight</div><div class="line">                onPress=&#123;this.handleOptionsButtonClick.bind(this)&#125;</div><div class="line">                onPress=&#123;e=&gt;this.handleOptionsButtonClick(e)&#125;</div><div class="line">                &gt;</div><div class="line">                &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt;</div><div class="line">            &lt;/TouchableHighlight&gt;</div><div class="line">        )</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 箭头函数的例子</div><div class="line">()=&gt;1</div><div class="line">v=&gt;v+1</div><div class="line">(a,b)=&gt;a+b</div><div class="line">()=&gt;&#123;</div><div class="line">    alert(&quot;foo&quot;);</div><div class="line">&#125;</div><div class="line">e=&gt;&#123;</div><div class="line">    if (e == 0)&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    return 1000/e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 错误的做法</div><div class="line">class PauseMenu extends React.Component&#123;</div><div class="line">    componentWillMount()&#123;</div><div class="line">        AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused.bind(this));</div><div class="line">    &#125;</div><div class="line">    componentDidUnmount()&#123;</div><div class="line">        AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused.bind(this));</div><div class="line">    &#125;</div><div class="line">    onAppPaused(event)&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 正确的做法</div><div class="line">class PauseMenu extends React.Component&#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props);</div><div class="line">        this._onAppPaused = this.onAppPaused.bind(this);</div><div class="line">    &#125;</div><div class="line">    componentWillMount()&#123;</div><div class="line">        AppStateIOS.addEventListener(&apos;change&apos;, this._onAppPaused);</div><div class="line">    &#125;</div><div class="line">    componentDidUnmount()&#123;</div><div class="line">        AppStateIOS.removeEventListener(&apos;change&apos;, this._onAppPaused);</div><div class="line">    &#125;</div><div class="line">    onAppPaused(event)&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个帖子中我们还学习到一种新的做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 正确的做法</div><div class="line">class PauseMenu extends React.Component&#123;</div><div class="line">    componentWillMount()&#123;</div><div class="line">        AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused);</div><div class="line">    &#125;</div><div class="line">    componentDidUnmount()&#123;</div><div class="line">        AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused);</div><div class="line">    &#125;</div><div class="line">    onAppPaused = (event) =&gt; &#123;</div><div class="line">        //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><p>在ES5下，我们经常使用mixin来为我们的类添加一些新的方法，譬如PureRenderMixin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var PureRenderMixin = require(&apos;react-addons-pure-render-mixin&apos;);</div><div class="line">React.createClass(&#123;</div><div class="line">  mixins: [PureRenderMixin],</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。</p>
<p>尽管如果要继续使用mixin，还是有一些第三方的方案可以用，譬如这个方案</p>
<p>不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，上文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//Enhance.js</div><div class="line">import &#123; Component &#125; from &quot;React&quot;;</div><div class="line"></div><div class="line">export var Enhance = ComposedComponent =&gt; class extends Component &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        this.state = &#123; data: null &#125;;</div><div class="line">    &#125;</div><div class="line">    componentDidMount() &#123;</div><div class="line">        this.setState(&#123; data: &apos;Hello&apos; &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;ComposedComponent &#123;...this.props&#125; data=&#123;this.state.data&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//HigherOrderComponent.js</div><div class="line">import &#123; Enhance &#125; from &quot;./Enhance&quot;;</div><div class="line"></div><div class="line">class MyComponent &#123;</div><div class="line">    render() &#123;</div><div class="line">        if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;;</div><div class="line">        return &lt;div&gt;&#123;this.data&#125;&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Enhance(MyComponent); // Enhanced component</div></pre></td></tr></table></figure></p>
<p>用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。</p>
<h2 id="ES6-带来的其它好处"><a href="#ES6-带来的其它好处" class="headerlink" title="ES6+带来的其它好处"></a>ES6+带来的其它好处</h2><h3 id="解构-amp-属性延展"><a href="#解构-amp-属性延展" class="headerlink" title="解构&amp;属性延展"></a>解构&amp;属性延展</h3><p>结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class AutoloadingPostsGrid extends React.Component &#123;</div><div class="line">render() &#123;</div><div class="line">var &#123;</div><div class="line">className,</div><div class="line">...others,  // contains all properties of this.props except for className</div><div class="line">&#125; = this.props;</div><div class="line">return (</div><div class="line">&lt;div className=&#123;className&#125;&gt;</div><div class="line">    &lt;PostsGrid &#123;...others&#125; /&gt;</div><div class="line">    &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这种写法，则是传递所有属性的同时，用覆盖新的className值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div &#123;...this.props&#125; className=&quot;override&quot;&gt;</div><div class="line">    …</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div className=&quot;base&quot; &#123;...this.props&#125;&gt;</div><div class="line">    …</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何将本地项目上传到git远程库?]]></title>
      <url>/2016/12/03/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0git%E8%BF%9C%E7%A8%8B%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>假如我想将本地项目上传到自己的git远程库，并且让这两个仓库进行远程同步，该如何操作呢?<br><a id="more"></a></p>
<h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><p><strong> 1、使用cd命令进入项目文件夹,通过命令 git init 把这个目录变成git可以管理的仓库； </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p>
<p><strong> 2、把文件添加到版本库中，使用命令 git add . 添加到暂存区里面去； </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add .</div></pre></td></tr></table></figure></p>
<p><strong> 3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明； </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &apos;first commit&apos;</div></pre></td></tr></table></figure></p>
<p><strong> 4、关联到远程库  首先，登陆GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库； </strong><br>git remote add origin 你的远程库地址,如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:yu520zhong/SomeProject.git</div></pre></td></tr></table></figure></p>
<p>origin这个名字一看就知道是远程库,马上就可以把本地库的所有内容推送到远程库上。<br><strong> 5、获取远程库与本地同步合并 防止远程库不为空导致提交会失败； </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull --rebase origin master</div></pre></td></tr></table></figure></p>
<p><strong> 6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。 </strong><br>我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<h2 id="几个命令"><a href="#几个命令" class="headerlink" title="几个命令"></a>几个命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git init 初始化/创建一个新的git仓库</div><div class="line">git add . 添加所有文件</div><div class="line">git commit -m “注释描述”  提交修改并且描述此次修改的内容</div><div class="line">git status  查询Git仓库状态</div><div class="line">git diff 查看 Git 仓库修改内容的差异</div><div class="line">git branch 使用和关联 git 分支</div><div class="line">git tag 使用和关联 git 标签</div><div class="line">git remote -v 列出详细信息，在每一个名字后面列出其远程url</div><div class="line">要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</div><div class="line">关联后，使用命令git push -u origin master第一次推送master分支的所有内容</div><div class="line">此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react-native中Navigator-is-deprecated的报错处理]]></title>
      <url>/2015/12/03/Navigator-is-deprecated-and-has-been-removed-from-this-package/</url>
      <content type="html"><![CDATA[<p>报错：Navigator is deprecated and has been removed from this package. It can now be installed…<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExceptionsManager.js:65 Navigator is deprecated and has been removed from this </div><div class="line">package. It can now be installed and imported from </div><div class="line">`react-native-deprecated-custom-components` instead of `react-native`. </div><div class="line">Learn about alternative navigation solutions at http://facebook.github.io/react-native/docs/navigation.html</div></pre></td></tr></table></figure></p>
<p><div class="tip"><br>  这是因为版本升级到0.43以上的话，Navigator不能直接从react-native里面获取了，<br></div></p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install react-native-deprecated-custom-components --save</div></pre></td></tr></table></figure>
<p>然后在引用的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123;Navigator&#125; from react-native-deprecated-custom-components`</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> error </category>
            
        </categories>
        
        
        <tags>
            
            <tag> error </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
