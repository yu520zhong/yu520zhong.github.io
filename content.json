{"meta":{"title":"Miuu","subtitle":"Miuu博客","description":"Miuu博客","author":"Miuu","url":"http://www.miuu.club"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-09-18T08:44:45.000Z","updated":"2017-09-18T08:58:09.000Z","comments":false,"path":"/404.html","permalink":"http://www.miuu.club//404.html","excerpt":"","text":"很抱歉，您所访问的地址并不存在: 回主页 · 所有文章 · 留言板 可在边栏搜索框中对本站进行检索，以获取相关信息。 以下是博主喜欢的一些歌曲，可以听听，稍作休息~ .article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"关于我","date":"2017-09-21T08:13:30.000Z","updated":"2017-09-21T08:21:12.000Z","comments":true,"path":"about/index.html","permalink":"http://www.miuu.club/about/index.html","excerpt":"","text":"以前人们在四月开始收获躺在高高的谷堆上面笑着我穿过 金黄的麦田去给 稻草人唱歌等着 落山风吹过 你从一座叫“我”的小镇经过刚好屋顶的雪化成雨飘落你穿着 透明的衣服给我 一个人唱歌全都是 我喜欢的歌 我们去大草原的湖边等候鸟飞回来等我们都长大了就生一个娃娃他会自己长大远去我们也各自远去我给你写信 你不会回信就这 样吧 以前人们在四月开始收获躺在高高的谷堆上面笑着我穿过 金黄的麦田去给 稻草人唱歌等着 落山风吹过 你从一座叫“我”的小镇经过刚好屋顶的雪化成雨飘落你穿着 透明的衣服给我 一个人唱歌全都是 我喜欢的歌 我们去大草原的湖边等候鸟飞回来等我们都长大了就生一个娃娃他会自己长大远去我们也各自远去我给你写信 你不会回信说好了吧 去大草原的湖边等候鸟飞回来等我们都长大了就生一个娃娃他会自己长大远去我们也各自远去我给你写信 你不要回信就这 样吧 啦呼就这 样吧"},{"title":"Tags","date":"2017-09-22T06:47:46.000Z","updated":"2017-09-19T02:20:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.miuu.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我喜欢的JS命名规则","slug":"我喜欢的JS命名规则","date":"2017-09-26T06:39:07.000Z","updated":"2017-09-26T06:49:24.000Z","comments":true,"path":"2017/09/26/我喜欢的JS命名规则/","link":"","permalink":"http://www.miuu.club/2017/09/26/我喜欢的JS命名规则/","excerpt":"JS命名方法有很多种,根据喜欢不同,一般情况下,我喜欢使用这样的命名我的JS:命名变量,用下划线来分割各个单词,其中前缀使用名词,并尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型,如title_text,max_count,current_abbr,table_title;","text":"JS命名方法有很多种,根据喜欢不同,一般情况下,我喜欢使用这样的命名我的JS:命名变量,用下划线来分割各个单词,其中前缀使用名词,并尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型,如title_text,max_count,current_abbr,table_title;命名函数,采用小驼峰式命名法,首字母小写,名字前缀为动词，以便区分变量和函数。如displayAbbreviations(),addLoadEvent(),getName();这样我就可以一样看出哪些是变量,哪些是函数。常量名称全部大写,使用大写字母和下划线来组合命名，下划线用以分割单词。如var MIN_COUNT = 10;构造函数,其采用new 运算符创建对象,使用大驼峰式命名法，首字母大写,前缀为名称。1234function Student(name) &#123; this.name = name;&#125;var student_name = new Student(&apos;tom&apos;);","categories":[{"name":"JS","slug":"JS","permalink":"http://www.miuu.club/categories/JS/"}],"tags":[{"name":"JS命名规则","slug":"JS命名规则","permalink":"http://www.miuu.club/tags/JS命名规则/"}]},{"title":"关于html5的webstorage——静态传值","slug":"关于html5的webstorage——静态传值","date":"2017-09-25T09:28:44.000Z","updated":"2017-09-26T06:49:44.000Z","comments":true,"path":"2017/09/25/关于html5的webstorage——静态传值/","link":"","permalink":"http://www.miuu.club/2017/09/25/关于html5的webstorage——静态传值/","excerpt":"html5静态页面之间的传值: localStorage、sessionStorage随着H5的到来，它提供了新的web存储，webstorage，包含了localStorage和sessionStoragelocalStorage：一种没有时间限制的缓存，我们不手动清理，就不丢失sessionStorage：用户的窗口执行了关闭操作，sessionStorage的数据会丢失","text":"html5静态页面之间的传值: localStorage、sessionStorage随着H5的到来，它提供了新的web存储，webstorage，包含了localStorage和sessionStoragelocalStorage：一种没有时间限制的缓存，我们不手动清理，就不丢失sessionStorage：用户的窗口执行了关闭操作，sessionStorage的数据会丢失先检测浏览器是不是支持H5的存储123if (window.localStorage &amp;&amp; window.sessionStorage) &#123; alert(&quot;你的浏览器支持localStorage和sessionStorage&quot;); &#125; 创建一个localStorage存储12//先判断支持 if (window.localStorage) &#123; localStorage.setItem(&quot;userName&quot;, &quot;张龙&quot;); &#125; 获取localStorage存储的数据1localStorage.getItem(&quot;userName&quot;); 最后操作删除localStorage存储1localStorage.removeItem(&quot;userName&quot;); //关闭缓存1localStorage.clear(); sessionStorage操作和localStorage基本操作一样！","categories":[{"name":"h5/css3","slug":"h5-css3","permalink":"http://www.miuu.club/categories/h5-css3/"}],"tags":[{"name":"localStorage","slug":"localStorage","permalink":"http://www.miuu.club/tags/localStorage/"}]},{"title":"webstorm支持sass的同步编译设置方法","slug":"webstorm支持sass的同步编译设置方法","date":"2017-09-25T03:06:14.000Z","updated":"2017-09-26T06:49:35.000Z","comments":true,"path":"2017/09/25/webstorm支持sass的同步编译设置方法/","link":"","permalink":"http://www.miuu.club/2017/09/25/webstorm支持sass的同步编译设置方法/","excerpt":"webstorm支持sass的同步编译,也就是即写即编译,并且可以指定编译后的css的目录。打开webstorm：点击左上角的File→Settings→File Watchers在弹窗的窗口的右上角点击绿色的 ‘+’ 号,然后选择scss","text":"webstorm支持sass的同步编译,也就是即写即编译,并且可以指定编译后的css的目录。打开webstorm：点击左上角的File→Settings→File Watchers在弹窗的窗口的右上角点击绿色的 ‘+’ 号,然后选择scssArguments:可以配置编译后的文件的输出路径,我这里写的是:–no-cache –update –sourcemap –watch $FileName$:$FileParentDir$/css/$FileNameWithoutExtension$.css注意, $FileName$后面有个冒号,然后$FileParentDir$表示的是scss文件所在的文件夹的父级文件夹,而不是scss文件的父文件夹。举个栗子,我的项目叫sass-learn,里面有个scss文件夹,里面存放scss文件,那么按照这样配置的结果,style.scss所在的文件夹就是scss,scss的父文件夹就是sass-learn,然后找到sass-learn下的css文件夹,编译后的style.css文件就会在这里。Output paths to refresh:改成这样:$FileNameWithoutExtension$.css:$FileNameWithoutExtension$.css.map","categories":[{"name":"sass","slug":"sass","permalink":"http://www.miuu.club/categories/sass/"}],"tags":[{"name":"webstrom","slug":"webstrom","permalink":"http://www.miuu.club/tags/webstrom/"}]},{"title":"又是一天","slug":"又是一天","date":"2017-09-22T15:22:21.000Z","updated":"2017-09-22T15:30:15.000Z","comments":true,"path":"2017/09/22/又是一天/","link":"","permalink":"http://www.miuu.club/2017/09/22/又是一天/","excerpt":"时间过得真快,又是一天,已经是又一个周五的晚上。","text":"时间过得真快,又是一天,已经是又一个周五的晚上。一个人在次卧的床上，听着歌，妻和嘟嘟都睡了。静静的夜里，远处小区的河边蛐蛐不停歇的叫声。手机里随机放着歌曲，陈粒的《奇妙能力歌》，只是随便听听，连一句歌词都没有记住，更不知道唱的什么意思。这样的夜不知道有多少，而白日却雷同地过着。轻叹一声，时间过得真快呀。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.miuu.club/categories/随笔/"}],"tags":[{"name":"随便写写","slug":"随便写写","permalink":"http://www.miuu.club/tags/随便写写/"}]},{"title":"随便写写","slug":"随便写写","date":"2017-09-21T07:56:26.000Z","updated":"2017-09-22T15:32:35.000Z","comments":true,"path":"2017/09/21/随便写写/","link":"","permalink":"http://www.miuu.club/2017/09/21/随便写写/","excerpt":"有时候很忙,就随便写写,有时候很闲,却不愿意写点什么。","text":"有时候很忙,就随便写写,有时候很闲,却不愿意写点什么。感觉没有紧迫感的时候，什么也做不成，有了紧迫感，却又感觉压力倍增。哎，随便写写吧，看了挤出来的时间，才会知道珍惜利用。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.miuu.club/categories/随笔/"}],"tags":[{"name":"随便写写","slug":"随便写写","permalink":"http://www.miuu.club/tags/随便写写/"}]},{"title":"对于React-React Native 的ES5 ES6写法对照表","slug":"对于React-React Native 的ES5 ES6写法对照表","date":"2017-09-07T07:29:26.000Z","updated":"2017-09-22T03:23:53.000Z","comments":true,"path":"2017/09/07/对于React-React Native 的ES5 ES6写法对照表/","link":"","permalink":"http://www.miuu.club/2017/09/07/对于React-React Native 的ES5 ES6写法对照表/","excerpt":"很多React/React Native的初学者都被ES6的问题迷惑：各路大神都建议我们直接学习ES6的语法(class Foo extends React.Component)，然而网上搜到的很多教程和例子都是ES5版本的，所以很多人在学习的时候连照猫画虎都不知道怎么做。今天在此整理了一些ES5和ES6的写法对照表，希望大家以后读到ES5的代码，也能通过对照，在ES6下实现相同的功能。","text":"很多React/React Native的初学者都被ES6的问题迷惑：各路大神都建议我们直接学习ES6的语法(class Foo extends React.Component)，然而网上搜到的很多教程和例子都是ES5版本的，所以很多人在学习的时候连照猫画虎都不知道怎么做。今天在此整理了一些ES5和ES6的写法对照表，希望大家以后读到ES5的代码，也能通过对照，在ES6下实现相同的功能。 模块引用在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样：123456789101112//ES5var React = require(\"react\");var &#123; Component, PropTypes&#125; = React; //引用React抽象组件var ReactNative = require(\"react-native\");var &#123; Image, Text,&#125; = ReactNative; //引用具体的React Native组件 在ES6里，import写法更为标准123456789//ES6import React, &#123; Component, PropTypes,&#125; from 'react';import &#123; Image, Text&#125; from 'react-native' 导出单个类 在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出12345//ES5var MyComponent = React.createClass(&#123; ...&#125;);module.exports = MyComponent; 在ES6里，通常用export default来实现相同的功能：1234//ES6export default class MyComponent extends Component&#123; ...&#125; 引用的时候也类似：12345//ES5var MyComponent = require('./MyComponent');//ES6import MyComponent from './MyComponent'; 注意导入和导出的写法必须配套，不能混用！ 定义组件在ES5里，通常通过React.createClass来定义一个组件类，像这样：12345678//ES5var Photo = React.createClass(&#123; render: function() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;,&#125;); 在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样：12345678//ES6class Photo extends React.Component &#123; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 给组件定义方法从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。12345678910111213141516171819202122//ES5var Photo = React.createClass(&#123; componentWillMount: function()&#123; &#125;, render: function() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;,&#125;);//ES6class Photo extends React.Component &#123; componentWillMount() &#123; &#125; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 定义组件的属性类型和默认属性在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现1234567891011121314151617181920//ES5var Video = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; autoPlay: false, maxLoops: 10, &#125;; &#125;, propTypes: &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return ( &lt;View /&gt; ); &#125;,&#125;); 在ES6里，可以统一使用static成员来实现123456789101112131415161718//ES6class Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125;; // 注意这里有分号 static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;; // 注意这里有分号 render() &#123; return ( &lt;View /&gt; ); &#125; // 注意这里既没有分号也没有逗号&#125; 也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思：123456789101112131415161718//ES6class Video extends React.Component &#123; render() &#123; return ( &lt;View /&gt; ); &#125;&#125;Video.defaultProps = &#123; autoPlay: false, maxLoops: 10,&#125;;Video.propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired,&#125;; 注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。 初始化STATEES5下情况类似，12345678//ES5var Video = React.createClass(&#123; getInitialState: function() &#123; return &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;,&#125;) ES6下，有两种写法：123456//ES6class Video extends React.Component &#123; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125; 不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：123456789//ES6class Video extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;&#125; 把方法作为回调提供很多习惯于ES6的用户反而不理解在ES5下可以这么做：1234567891011121314//ES5var PostInfo = React.createClass(&#123; handleOptionsButtonClick: function(e) &#123; // Here, &apos;this&apos; refers to the component instance. this.setState(&#123;showOptionsModal: true&#125;); &#125;, render: function()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick&#125;&gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125;); 在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用1234567891011121314151617//ES6class PostInfo extends React.Component&#123; handleOptionsButtonClick(e)&#123; this.setState(&#123;showOptionsModal: true&#125;); &#125; render()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick.bind(this)&#125; onPress=&#123;e=&gt;this.handleOptionsButtonClick(e)&#125; &gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125; 箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。12345678910111213// 箭头函数的例子()=&gt;1v=&gt;v+1(a,b)=&gt;a+b()=&gt;&#123; alert(&quot;foo&quot;);&#125;e=&gt;&#123; if (e == 0)&#123; return 0; &#125; return 1000/e;&#125; 需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用1234567891011121314151617181920212223242526// 错误的做法class PauseMenu extends React.Component&#123; componentWillMount()&#123; AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused.bind(this)); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused.bind(this)); &#125; onAppPaused(event)&#123; &#125;&#125;// 正确的做法class PauseMenu extends React.Component&#123; constructor(props)&#123; super(props); this._onAppPaused = this.onAppPaused.bind(this); &#125; componentWillMount()&#123; AppStateIOS.addEventListener(&apos;change&apos;, this._onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener(&apos;change&apos;, this._onAppPaused); &#125; onAppPaused(event)&#123; &#125;&#125; 从这个帖子中我们还学习到一种新的做法：123456789101112// 正确的做法class PauseMenu extends React.Component&#123; componentWillMount()&#123; AppStateIOS.addEventListener(&apos;change&apos;, this.onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener(&apos;change&apos;, this.onAppPaused); &#125; onAppPaused = (event) =&gt; &#123; //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针 &#125;&#125; Mixins在ES5下，我们经常使用mixin来为我们的类添加一些新的方法，譬如PureRenderMixin12345678var PureRenderMixin = require(&apos;react-addons-pure-render-mixin&apos;);React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。 尽管如果要继续使用mixin，还是有一些第三方的方案可以用，譬如这个方案 不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，上文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式：12345678910111213141516171819202122232425//Enhance.jsimport &#123; Component &#125; from &quot;React&quot;;export var Enhance = ComposedComponent =&gt; class extends Component &#123; constructor() &#123; this.state = &#123; data: null &#125;; &#125; componentDidMount() &#123; this.setState(&#123; data: &apos;Hello&apos; &#125;); &#125; render() &#123; return &lt;ComposedComponent &#123;...this.props&#125; data=&#123;this.state.data&#125; /&gt;; &#125;&#125;;//HigherOrderComponent.jsimport &#123; Enhance &#125; from &quot;./Enhance&quot;;class MyComponent &#123; render() &#123; if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;; return &lt;div&gt;&#123;this.data&#125;&lt;/div&gt;; &#125;&#125;export default Enhance(MyComponent); // Enhanced component 用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。 ES6+带来的其它好处解构&amp;属性延展结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签：1234567891011121314class AutoloadingPostsGrid extends React.Component &#123;render() &#123;var &#123;className,...others, // contains all properties of this.props except for className&#125; = this.props;return (&lt;div className=&#123;className&#125;&gt; &lt;PostsGrid &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt;&lt;/div&gt;);&#125;&#125; 下面这种写法，则是传递所有属性的同时，用覆盖新的className值：123&lt;div &#123;...this.props&#125; className=&quot;override&quot;&gt; …&lt;/div&gt; 这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值123&lt;div className=&quot;base&quot; &#123;...this.props&#125;&gt; …&lt;/div&gt;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.miuu.club/tags/ES6/"}]},{"title":"如何将本地项目上传到git远程库?","slug":"如何将本地项目上传到git远程库","date":"2016-12-02T16:00:00.000Z","updated":"2017-09-21T08:25:40.000Z","comments":true,"path":"2016/12/03/如何将本地项目上传到git远程库/","link":"","permalink":"http://www.miuu.club/2016/12/03/如何将本地项目上传到git远程库/","excerpt":"假如我想将本地项目上传到自己的git远程库，并且让这两个仓库进行远程同步，该如何操作呢?","text":"假如我想将本地项目上传到自己的git远程库，并且让这两个仓库进行远程同步，该如何操作呢? 详细步骤 1、使用cd命令进入项目文件夹,通过命令 git init 把这个目录变成git可以管理的仓库； 1git init 2、把文件添加到版本库中，使用命令 git add . 添加到暂存区里面去； 1git add . 3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明； 1git commit -m &apos;first commit&apos; 4、关联到远程库 首先，登陆GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库； git remote add origin 你的远程库地址,如：1git remote add origin git@github.com:yu520zhong/SomeProject.git origin这个名字一看就知道是远程库,马上就可以把本地库的所有内容推送到远程库上。 5、获取远程库与本地同步合并 防止远程库不为空导致提交会失败； 1git pull --rebase origin master 6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。 我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。1git push -u origin master 几个命令1234567891011git init 初始化/创建一个新的git仓库git add . 添加所有文件git commit -m “注释描述” 提交修改并且描述此次修改的内容git status 查询Git仓库状态git diff 查看 Git 仓库修改内容的差异git branch 使用和关联 git 分支git tag 使用和关联 git 标签git remote -v 列出详细信息，在每一个名字后面列出其远程url要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；","categories":[{"name":"Git","slug":"Git","permalink":"http://www.miuu.club/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.miuu.club/tags/Git/"}]},{"title":"react-native中Navigator-is-deprecated的报错处理","slug":"Navigator-is-deprecated-and-has-been-removed-from-this-package","date":"2015-12-03T04:00:00.000Z","updated":"2017-09-26T06:49:31.000Z","comments":true,"path":"2015/12/03/Navigator-is-deprecated-and-has-been-removed-from-this-package/","link":"","permalink":"http://www.miuu.club/2015/12/03/Navigator-is-deprecated-and-has-been-removed-from-this-package/","excerpt":"报错：Navigator is deprecated and has been removed from this package. It can now be installed…","text":"报错：Navigator is deprecated and has been removed from this package. It can now be installed…1234ExceptionsManager.js:65 Navigator is deprecated and has been removed from this package. It can now be installed and imported from `react-native-deprecated-custom-components` instead of `react-native`. Learn about alternative navigation solutions at http://facebook.github.io/react-native/docs/navigation.html 这是因为版本升级到0.43以上的话，Navigator不能直接从react-native里面获取了， 解决方案：1npm install react-native-deprecated-custom-components --save 然后在引用的地方1import &#123;Navigator&#125; from react-native-deprecated-custom-components`","categories":[{"name":"error","slug":"error","permalink":"http://www.miuu.club/categories/error/"}],"tags":[{"name":"error","slug":"error","permalink":"http://www.miuu.club/tags/error/"}]}]}